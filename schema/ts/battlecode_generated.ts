// automatically generated by the FlatBuffers compiler, do not modify

import { flatbuffers } from "flatbuffers"
/**
 * The possible types of things that can exist.
 * Note that bullets are not treated as bodies.
 *
 * @enum {number}
 */
export namespace battlecode.schema{
export enum BodyType{
  /**
   * Enlightenment centers produce politicians, Muckrakers and slanderers and place bids
   *can be neutral until captured
   */
  ENLIGHTENMENT_CENTER= 0,

  /**
   * politicians use their influence to self destruct and capture other units
   */
  POLITICIAN= 1,

  /**
   * slanderers generate passive influence for the enlightenment center that created them
   * they turn into politicians at some point, and can only be identified by slanderers.
   */
  SLANDERER= 2,

  /**
   * have the ability to identify slanderers
   */
  MUCKRAKER= 3
}};

/**
 * Actions that can be performed.
 * Purely aesthetic; have no actual effect on simulation.
 * (Although the simulation may want to track the 'parents' of
 * particular robots.)
 * Actions may have 'targets', which are the units on which
 * the actions were performed.
 *
 * @enum {number}
 */
export namespace battlecode.schema{
export enum Action{
  /**
   * Politicians self-destruct and affect nearby bodies.
   * Target: none
   */
  EMPOWER= 0,

  /**
   * Muckrakers can expose a slanderer.
   * Target: an enemy body
   */
  EXPOSE= 1,

  /**
   * Units can change their flag.
   * Target: new flag value
   */
  SET_FLAG= 2,

  /**
   * Builds a unit.
   * Target: spawned unit
   */
  SPAWN_UNIT= 3,

  /**
   * Places a bid.
   * Target: bid value
   */
  PLACE_BID= 4,

  /**
   * A robot can change team after being empowered,
   * or when a Enlightenment Center is taken over.
   * Target: teamID
   */
  CHANGE_TEAM= 5,

  /**
   * A robot's influence changes.
   * Target: delta value
   */
  CHANGE_INFLUENCE= 6,

  /**
   * A robot's conviction changes.
   * Target: delta value, i.e. red 5 -> blue 3 is -2
   */
  CHANGE_CONVICTION= 7,

  /**
   * Dies due to an uncaught exception.
   * Target: none
   */
  DIE_EXCEPTION= 8
}};

/**
 * Events
 * An Event is a single step that needs to be processed.
 * A saved game simply consists of a long list of Events.
 * Events can be divided by either being sent separately (e.g. as separate
 * websocket messages), or by being wrapped with a GameWrapper.
 * A game consists of a series of matches; a match consists of a series of
 * rounds, and is played on a single map. Each round is a single simulation
 * step.
 *
 * @enum {number}
 */
export namespace battlecode.schema{
export enum Event{
  NONE= 0,

  /**
   * There should only be one GameHeader, at the start of the stream.
   */
  GameHeader= 1,

  /**
   * There should be one MatchHeader at the start of each match.
   */
  MatchHeader= 2,

  /**
   * A single simulation step. A round may be skipped if
   * nothing happens during its time.
   */
  Round= 3,

  /**
   * There should be one MatchFooter at the end of each simulation step.
   */
  MatchFooter= 4,

  /**
   * There should only be one GameFooter, at the end of the stream.
   */
  GameFooter= 5
}};

/**
 * A vector in two-dimensional space. Discrete space, of course.
 * Defaults to the 0 vector.
 *
 * @constructor
 */
export namespace battlecode.schema{
export class Vec {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns Vec
 */
__init(i:number, bb:flatbuffers.ByteBuffer):Vec {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @returns number
 */
x():number {
  return this.bb!.readInt32(this.bb_pos);
};

/**
 * @returns number
 */
y():number {
  return this.bb!.readInt32(this.bb_pos + 4);
};

/**
 * @param flatbuffers.Builder builder
 * @param number x
 * @param number y
 * @returns flatbuffers.Offset
 */
static createVec(builder:flatbuffers.Builder, x: number, y: number):flatbuffers.Offset {
  builder.prep(4, 8);
  builder.writeInt32(y);
  builder.writeInt32(x);
  return builder.offset();
};

}
}
/**
 * A table of vectors.
 *
 * @constructor
 */
export namespace battlecode.schema{
export class VecTable {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns VecTable
 */
__init(i:number, bb:flatbuffers.ByteBuffer):VecTable {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param VecTable= obj
 * @returns VecTable
 */
static getRootAsVecTable(bb:flatbuffers.ByteBuffer, obj?:VecTable):VecTable {
  return (obj || new VecTable()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param VecTable= obj
 * @returns VecTable
 */
static getSizePrefixedRootAsVecTable(bb:flatbuffers.ByteBuffer, obj?:VecTable):VecTable {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new VecTable()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param number index
 * @returns number
 */
xs(index: number):number|null {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
};

/**
 * @returns number
 */
xsLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int32Array
 */
xsArray():Int32Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? new Int32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * @param number index
 * @returns number
 */
ys(index: number):number|null {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
};

/**
 * @returns number
 */
ysLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int32Array
 */
ysArray():Int32Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? new Int32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * @param flatbuffers.Builder builder
 */
static startVecTable(builder:flatbuffers.Builder) {
  builder.startObject(2);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset xsOffset
 */
static addXs(builder:flatbuffers.Builder, xsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, xsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<number> data
 * @returns flatbuffers.Offset
 */
static createXsVector(builder:flatbuffers.Builder, data:number[] | Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startXsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset ysOffset
 */
static addYs(builder:flatbuffers.Builder, ysOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, ysOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<number> data
 * @returns flatbuffers.Offset
 */
static createYsVector(builder:flatbuffers.Builder, data:number[] | Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startYsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
static endVecTable(builder:flatbuffers.Builder):flatbuffers.Offset {
  var offset = builder.endObject();
  return offset;
};

static createVecTable(builder:flatbuffers.Builder, xsOffset:flatbuffers.Offset, ysOffset:flatbuffers.Offset):flatbuffers.Offset {
  VecTable.startVecTable(builder);
  VecTable.addXs(builder, xsOffset);
  VecTable.addYs(builder, ysOffset);
  return VecTable.endVecTable(builder);
}
}
}
/**
 * A table of RGB values.
 *
 * @constructor
 */
export namespace battlecode.schema{
export class RGBTable {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns RGBTable
 */
__init(i:number, bb:flatbuffers.ByteBuffer):RGBTable {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param RGBTable= obj
 * @returns RGBTable
 */
static getRootAsRGBTable(bb:flatbuffers.ByteBuffer, obj?:RGBTable):RGBTable {
  return (obj || new RGBTable()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param RGBTable= obj
 * @returns RGBTable
 */
static getSizePrefixedRootAsRGBTable(bb:flatbuffers.ByteBuffer, obj?:RGBTable):RGBTable {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new RGBTable()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param number index
 * @returns number
 */
red(index: number):number|null {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
};

/**
 * @returns number
 */
redLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int32Array
 */
redArray():Int32Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? new Int32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * @param number index
 * @returns number
 */
green(index: number):number|null {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
};

/**
 * @returns number
 */
greenLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int32Array
 */
greenArray():Int32Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? new Int32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * @param number index
 * @returns number
 */
blue(index: number):number|null {
  var offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
};

/**
 * @returns number
 */
blueLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int32Array
 */
blueArray():Int32Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? new Int32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * @param flatbuffers.Builder builder
 */
static startRGBTable(builder:flatbuffers.Builder) {
  builder.startObject(3);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset redOffset
 */
static addRed(builder:flatbuffers.Builder, redOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, redOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<number> data
 * @returns flatbuffers.Offset
 */
static createRedVector(builder:flatbuffers.Builder, data:number[] | Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startRedVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset greenOffset
 */
static addGreen(builder:flatbuffers.Builder, greenOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, greenOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<number> data
 * @returns flatbuffers.Offset
 */
static createGreenVector(builder:flatbuffers.Builder, data:number[] | Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startGreenVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset blueOffset
 */
static addBlue(builder:flatbuffers.Builder, blueOffset:flatbuffers.Offset) {
  builder.addFieldOffset(2, blueOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<number> data
 * @returns flatbuffers.Offset
 */
static createBlueVector(builder:flatbuffers.Builder, data:number[] | Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startBlueVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
static endRGBTable(builder:flatbuffers.Builder):flatbuffers.Offset {
  var offset = builder.endObject();
  return offset;
};

static createRGBTable(builder:flatbuffers.Builder, redOffset:flatbuffers.Offset, greenOffset:flatbuffers.Offset, blueOffset:flatbuffers.Offset):flatbuffers.Offset {
  RGBTable.startRGBTable(builder);
  RGBTable.addRed(builder, redOffset);
  RGBTable.addGreen(builder, greenOffset);
  RGBTable.addBlue(builder, blueOffset);
  return RGBTable.endRGBTable(builder);
}
}
}
/**
 * A list of new bodies to be placed on the map.
 *
 * @constructor
 */
export namespace battlecode.schema{
export class SpawnedBodyTable {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns SpawnedBodyTable
 */
__init(i:number, bb:flatbuffers.ByteBuffer):SpawnedBodyTable {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param SpawnedBodyTable= obj
 * @returns SpawnedBodyTable
 */
static getRootAsSpawnedBodyTable(bb:flatbuffers.ByteBuffer, obj?:SpawnedBodyTable):SpawnedBodyTable {
  return (obj || new SpawnedBodyTable()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param SpawnedBodyTable= obj
 * @returns SpawnedBodyTable
 */
static getSizePrefixedRootAsSpawnedBodyTable(bb:flatbuffers.ByteBuffer, obj?:SpawnedBodyTable):SpawnedBodyTable {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new SpawnedBodyTable()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * The numeric ID of the new bodies.
 * Will never be negative.
 * There will only be one body with a particular ID at a time.
 * So, there will never be two robots with the same ID, or a robot and
 * a building with the same ID.
 *
 * @param number index
 * @returns number
 */
robotIDs(index: number):number|null {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
};

/**
 * @returns number
 */
robotIDsLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int32Array
 */
robotIDsArray():Int32Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? new Int32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * The teams of the new bodies.
 *
 * @param number index
 * @returns number
 */
teamIDs(index: number):number|null {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.readInt8(this.bb!.__vector(this.bb_pos + offset) + index) : 0;
};

/**
 * @returns number
 */
teamIDsLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int8Array
 */
teamIDsArray():Int8Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? new Int8Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * The types of the new bodies.
 *
 * @param number index
 * @returns battlecode.schema.BodyType
 */
types(index: number):battlecode.schema.BodyType|null {
  var offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? /**  */ (this.bb!.readInt8(this.bb!.__vector(this.bb_pos + offset) + index)) : /**  */ (0);
};

/**
 * @returns number
 */
typesLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int8Array
 */
typesArray():Int8Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? new Int8Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * The locations of the bodies.
 *
 * @param battlecode.schema.VecTable= obj
 * @returns battlecode.schema.VecTable|null
 */
locs(obj?:battlecode.schema.VecTable):battlecode.schema.VecTable|null {
  var offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? (obj || new battlecode.schema.VecTable()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;
};

/**
 * the amount of influence paid to create these bodies
 * for initial Enlightenment Centers, this is the amount of influence
 * needed to take over
 *
 * @param number index
 * @returns number
 */
influences(index: number):number|null {
  var offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
};

/**
 * @returns number
 */
influencesLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int32Array
 */
influencesArray():Int32Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? new Int32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * @param flatbuffers.Builder builder
 */
static startSpawnedBodyTable(builder:flatbuffers.Builder) {
  builder.startObject(5);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset robotIDsOffset
 */
static addRobotIDs(builder:flatbuffers.Builder, robotIDsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, robotIDsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<number> data
 * @returns flatbuffers.Offset
 */
static createRobotIDsVector(builder:flatbuffers.Builder, data:number[] | Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startRobotIDsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset teamIDsOffset
 */
static addTeamIDs(builder:flatbuffers.Builder, teamIDsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, teamIDsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<number> data
 * @returns flatbuffers.Offset
 */
static createTeamIDsVector(builder:flatbuffers.Builder, data:number[] | Uint8Array):flatbuffers.Offset {
  builder.startVector(1, data.length, 1);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt8(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startTeamIDsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(1, numElems, 1);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset typesOffset
 */
static addTypes(builder:flatbuffers.Builder, typesOffset:flatbuffers.Offset) {
  builder.addFieldOffset(2, typesOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<battlecode.schema.BodyType> data
 * @returns flatbuffers.Offset
 */
static createTypesVector(builder:flatbuffers.Builder, data:battlecode.schema.BodyType[]):flatbuffers.Offset {
  builder.startVector(1, data.length, 1);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt8(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startTypesVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(1, numElems, 1);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset locsOffset
 */
static addLocs(builder:flatbuffers.Builder, locsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(3, locsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset influencesOffset
 */
static addInfluences(builder:flatbuffers.Builder, influencesOffset:flatbuffers.Offset) {
  builder.addFieldOffset(4, influencesOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<number> data
 * @returns flatbuffers.Offset
 */
static createInfluencesVector(builder:flatbuffers.Builder, data:number[] | Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startInfluencesVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
static endSpawnedBodyTable(builder:flatbuffers.Builder):flatbuffers.Offset {
  var offset = builder.endObject();
  return offset;
};

static createSpawnedBodyTable(builder:flatbuffers.Builder, robotIDsOffset:flatbuffers.Offset, teamIDsOffset:flatbuffers.Offset, typesOffset:flatbuffers.Offset, locsOffset:flatbuffers.Offset, influencesOffset:flatbuffers.Offset):flatbuffers.Offset {
  SpawnedBodyTable.startSpawnedBodyTable(builder);
  SpawnedBodyTable.addRobotIDs(builder, robotIDsOffset);
  SpawnedBodyTable.addTeamIDs(builder, teamIDsOffset);
  SpawnedBodyTable.addTypes(builder, typesOffset);
  SpawnedBodyTable.addLocs(builder, locsOffset);
  SpawnedBodyTable.addInfluences(builder, influencesOffset);
  return SpawnedBodyTable.endSpawnedBodyTable(builder);
}
}
}
/**
 * The map a round is played on.
 *
 * @constructor
 */
export namespace battlecode.schema{
export class GameMap {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns GameMap
 */
__init(i:number, bb:flatbuffers.ByteBuffer):GameMap {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param GameMap= obj
 * @returns GameMap
 */
static getRootAsGameMap(bb:flatbuffers.ByteBuffer, obj?:GameMap):GameMap {
  return (obj || new GameMap()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param GameMap= obj
 * @returns GameMap
 */
static getSizePrefixedRootAsGameMap(bb:flatbuffers.ByteBuffer, obj?:GameMap):GameMap {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new GameMap()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * The name of a map.
 *
 * @param flatbuffers.Encoding= optionalEncoding
 * @returns string|Uint8Array|null
 */
name():string|null
name(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
name(optionalEncoding?:any):string|Uint8Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
};

/**
 * The bottom corner of the map.
 *
 * @param battlecode.schema.Vec= obj
 * @returns battlecode.schema.Vec|null
 */
minCorner(obj?:battlecode.schema.Vec):battlecode.schema.Vec|null {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? (obj || new battlecode.schema.Vec()).__init(this.bb_pos + offset, this.bb!) : null;
};

/**
 * The top corner of the map.
 *
 * @param battlecode.schema.Vec= obj
 * @returns battlecode.schema.Vec|null
 */
maxCorner(obj?:battlecode.schema.Vec):battlecode.schema.Vec|null {
  var offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? (obj || new battlecode.schema.Vec()).__init(this.bb_pos + offset, this.bb!) : null;
};

/**
 * The bodies on the map.
 *
 * @param battlecode.schema.SpawnedBodyTable= obj
 * @returns battlecode.schema.SpawnedBodyTable|null
 */
bodies(obj?:battlecode.schema.SpawnedBodyTable):battlecode.schema.SpawnedBodyTable|null {
  var offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? (obj || new battlecode.schema.SpawnedBodyTable()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;
};

/**
 * The random seed of the map.
 *
 * @returns number
 */
randomSeed():number {
  var offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
};

/**
 * The factor to divide cooldowns by
 *
 * @param number index
 * @returns number
 */
passability(index: number):number|null {
  var offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.readFloat64(this.bb!.__vector(this.bb_pos + offset) + index * 8) : 0;
};

/**
 * @returns number
 */
passabilityLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Float64Array
 */
passabilityArray():Float64Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? new Float64Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * @param flatbuffers.Builder builder
 */
static startGameMap(builder:flatbuffers.Builder) {
  builder.startObject(6);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset nameOffset
 */
static addName(builder:flatbuffers.Builder, nameOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, nameOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset minCornerOffset
 */
static addMinCorner(builder:flatbuffers.Builder, minCornerOffset:flatbuffers.Offset) {
  builder.addFieldStruct(1, minCornerOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset maxCornerOffset
 */
static addMaxCorner(builder:flatbuffers.Builder, maxCornerOffset:flatbuffers.Offset) {
  builder.addFieldStruct(2, maxCornerOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset bodiesOffset
 */
static addBodies(builder:flatbuffers.Builder, bodiesOffset:flatbuffers.Offset) {
  builder.addFieldOffset(3, bodiesOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param number randomSeed
 */
static addRandomSeed(builder:flatbuffers.Builder, randomSeed:number) {
  builder.addFieldInt32(4, randomSeed, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset passabilityOffset
 */
static addPassability(builder:flatbuffers.Builder, passabilityOffset:flatbuffers.Offset) {
  builder.addFieldOffset(5, passabilityOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<number> data
 * @returns flatbuffers.Offset
 */
static createPassabilityVector(builder:flatbuffers.Builder, data:number[] | Uint8Array):flatbuffers.Offset {
  builder.startVector(8, data.length, 8);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addFloat64(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startPassabilityVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(8, numElems, 8);
};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
static endGameMap(builder:flatbuffers.Builder):flatbuffers.Offset {
  var offset = builder.endObject();
  return offset;
};

static createGameMap(builder:flatbuffers.Builder, nameOffset:flatbuffers.Offset, minCornerOffset:flatbuffers.Offset, maxCornerOffset:flatbuffers.Offset, bodiesOffset:flatbuffers.Offset, randomSeed:number, passabilityOffset:flatbuffers.Offset):flatbuffers.Offset {
  GameMap.startGameMap(builder);
  GameMap.addName(builder, nameOffset);
  GameMap.addMinCorner(builder, minCornerOffset);
  GameMap.addMaxCorner(builder, maxCornerOffset);
  GameMap.addBodies(builder, bodiesOffset);
  GameMap.addRandomSeed(builder, randomSeed);
  GameMap.addPassability(builder, passabilityOffset);
  return GameMap.endGameMap(builder);
}
}
}
/**
 * Metadata about all bodies of a particular type.
 *
 * @constructor
 */
export namespace battlecode.schema{
export class BodyTypeMetadata {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns BodyTypeMetadata
 */
__init(i:number, bb:flatbuffers.ByteBuffer):BodyTypeMetadata {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param BodyTypeMetadata= obj
 * @returns BodyTypeMetadata
 */
static getRootAsBodyTypeMetadata(bb:flatbuffers.ByteBuffer, obj?:BodyTypeMetadata):BodyTypeMetadata {
  return (obj || new BodyTypeMetadata()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param BodyTypeMetadata= obj
 * @returns BodyTypeMetadata
 */
static getSizePrefixedRootAsBodyTypeMetadata(bb:flatbuffers.ByteBuffer, obj?:BodyTypeMetadata):BodyTypeMetadata {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new BodyTypeMetadata()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * The relevant type.
 *
 * @returns battlecode.schema.BodyType
 */
type():battlecode.schema.BodyType {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? /**  */ (this.bb!.readInt8(this.bb_pos + offset)) : battlecode.schema.BodyType.ENLIGHTENMENT_CENTER;
};

/**
 * The spawn source.
 *
 * @returns battlecode.schema.BodyType
 */
spawnSource():battlecode.schema.BodyType {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? /**  */ (this.bb!.readInt8(this.bb_pos + offset)) : battlecode.schema.BodyType.ENLIGHTENMENT_CENTER;
};

/**
 * the convictionRatio of this type
 *
 * @returns number
 */
convictionRatio():number {
  var offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
};

/**
 * cooldown of this type
 *
 * @returns number
 */
actionCooldown():number {
  var offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
};

/**
 * action radius if this type
 *
 * @returns number
 */
actionRadiusSquared():number {
  var offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
};

/**
 * sensor radius squared for this type
 *
 * @returns number
 */
sensorRadiusSquared():number {
  var offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
};

/**
 * detection radius of this type
 *
 * @returns number
 */
detectionRadiusSquared():number {
  var offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
};

/**
 * bytecode limit for this type
 *
 * @returns number
 */
bytecodeLimit():number {
  var offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
};

/**
 * @param flatbuffers.Builder builder
 */
static startBodyTypeMetadata(builder:flatbuffers.Builder) {
  builder.startObject(8);
};

/**
 * @param flatbuffers.Builder builder
 * @param battlecode.schema.BodyType type
 */
static addType(builder:flatbuffers.Builder, type:battlecode.schema.BodyType) {
  builder.addFieldInt8(0, type, battlecode.schema.BodyType.ENLIGHTENMENT_CENTER);
};

/**
 * @param flatbuffers.Builder builder
 * @param battlecode.schema.BodyType spawnSource
 */
static addSpawnSource(builder:flatbuffers.Builder, spawnSource:battlecode.schema.BodyType) {
  builder.addFieldInt8(1, spawnSource, battlecode.schema.BodyType.ENLIGHTENMENT_CENTER);
};

/**
 * @param flatbuffers.Builder builder
 * @param number convictionRatio
 */
static addConvictionRatio(builder:flatbuffers.Builder, convictionRatio:number) {
  builder.addFieldFloat32(2, convictionRatio, 0.0);
};

/**
 * @param flatbuffers.Builder builder
 * @param number actionCooldown
 */
static addActionCooldown(builder:flatbuffers.Builder, actionCooldown:number) {
  builder.addFieldInt32(3, actionCooldown, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param number actionRadiusSquared
 */
static addActionRadiusSquared(builder:flatbuffers.Builder, actionRadiusSquared:number) {
  builder.addFieldInt32(4, actionRadiusSquared, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param number sensorRadiusSquared
 */
static addSensorRadiusSquared(builder:flatbuffers.Builder, sensorRadiusSquared:number) {
  builder.addFieldInt32(5, sensorRadiusSquared, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param number detectionRadiusSquared
 */
static addDetectionRadiusSquared(builder:flatbuffers.Builder, detectionRadiusSquared:number) {
  builder.addFieldInt32(6, detectionRadiusSquared, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param number bytecodeLimit
 */
static addBytecodeLimit(builder:flatbuffers.Builder, bytecodeLimit:number) {
  builder.addFieldInt32(7, bytecodeLimit, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
static endBodyTypeMetadata(builder:flatbuffers.Builder):flatbuffers.Offset {
  var offset = builder.endObject();
  return offset;
};

static createBodyTypeMetadata(builder:flatbuffers.Builder, type:battlecode.schema.BodyType, spawnSource:battlecode.schema.BodyType, convictionRatio:number, actionCooldown:number, actionRadiusSquared:number, sensorRadiusSquared:number, detectionRadiusSquared:number, bytecodeLimit:number):flatbuffers.Offset {
  BodyTypeMetadata.startBodyTypeMetadata(builder);
  BodyTypeMetadata.addType(builder, type);
  BodyTypeMetadata.addSpawnSource(builder, spawnSource);
  BodyTypeMetadata.addConvictionRatio(builder, convictionRatio);
  BodyTypeMetadata.addActionCooldown(builder, actionCooldown);
  BodyTypeMetadata.addActionRadiusSquared(builder, actionRadiusSquared);
  BodyTypeMetadata.addSensorRadiusSquared(builder, sensorRadiusSquared);
  BodyTypeMetadata.addDetectionRadiusSquared(builder, detectionRadiusSquared);
  BodyTypeMetadata.addBytecodeLimit(builder, bytecodeLimit);
  return BodyTypeMetadata.endBodyTypeMetadata(builder);
}
}
}
/**
 * Data relevant to a particular team.
 *
 * @constructor
 */
export namespace battlecode.schema{
export class TeamData {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns TeamData
 */
__init(i:number, bb:flatbuffers.ByteBuffer):TeamData {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param TeamData= obj
 * @returns TeamData
 */
static getRootAsTeamData(bb:flatbuffers.ByteBuffer, obj?:TeamData):TeamData {
  return (obj || new TeamData()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param TeamData= obj
 * @returns TeamData
 */
static getSizePrefixedRootAsTeamData(bb:flatbuffers.ByteBuffer, obj?:TeamData):TeamData {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new TeamData()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * The name of the team.
 *
 * @param flatbuffers.Encoding= optionalEncoding
 * @returns string|Uint8Array|null
 */
name():string|null
name(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
name(optionalEncoding?:any):string|Uint8Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
};

/**
 * The java package the team uses.
 *
 * @param flatbuffers.Encoding= optionalEncoding
 * @returns string|Uint8Array|null
 */
packageName():string|null
packageName(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
packageName(optionalEncoding?:any):string|Uint8Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
};

/**
 * The ID of the team this data pertains to.
 *
 * @returns number
 */
teamID():number {
  var offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.readInt8(this.bb_pos + offset) : 0;
};

/**
 * @param flatbuffers.Builder builder
 */
static startTeamData(builder:flatbuffers.Builder) {
  builder.startObject(3);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset nameOffset
 */
static addName(builder:flatbuffers.Builder, nameOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, nameOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset packageNameOffset
 */
static addPackageName(builder:flatbuffers.Builder, packageNameOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, packageNameOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param number teamID
 */
static addTeamID(builder:flatbuffers.Builder, teamID:number) {
  builder.addFieldInt8(2, teamID, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
static endTeamData(builder:flatbuffers.Builder):flatbuffers.Offset {
  var offset = builder.endObject();
  return offset;
};

static createTeamData(builder:flatbuffers.Builder, nameOffset:flatbuffers.Offset, packageNameOffset:flatbuffers.Offset, teamID:number):flatbuffers.Offset {
  TeamData.startTeamData(builder);
  TeamData.addName(builder, nameOffset);
  TeamData.addPackageName(builder, packageNameOffset);
  TeamData.addTeamID(builder, teamID);
  return TeamData.endTeamData(builder);
}
}
}
/**
 * Profiler tables
 * These tables are set-up so that they match closely with speedscope's file format documented at
 * https://github.com/jlfwong/speedscope/wiki/Importing-from-custom-sources.
 * The client uses speedscope to show the recorded data in an interactive interface.
 * A single event in a profile. Represents either an open event (meaning a
 * method has been entered) or a close event (meaning the method was exited).
 *
 * @constructor
 */
export namespace battlecode.schema{
export class ProfilerEvent {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns ProfilerEvent
 */
__init(i:number, bb:flatbuffers.ByteBuffer):ProfilerEvent {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param ProfilerEvent= obj
 * @returns ProfilerEvent
 */
static getRootAsProfilerEvent(bb:flatbuffers.ByteBuffer, obj?:ProfilerEvent):ProfilerEvent {
  return (obj || new ProfilerEvent()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param ProfilerEvent= obj
 * @returns ProfilerEvent
 */
static getSizePrefixedRootAsProfilerEvent(bb:flatbuffers.ByteBuffer, obj?:ProfilerEvent):ProfilerEvent {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new ProfilerEvent()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * Whether this is an open event (true) or a close event (false).
 *
 * @returns boolean
 */
isOpen():boolean {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
};

/**
 * The bytecode counter at the time the event occurred.
 *
 * @returns number
 */
at():number {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
};

/**
 * The index of the method name in the ProfilerFile.frames array.
 *
 * @returns number
 */
frame():number {
  var offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
};

/**
 * @param flatbuffers.Builder builder
 */
static startProfilerEvent(builder:flatbuffers.Builder) {
  builder.startObject(3);
};

/**
 * @param flatbuffers.Builder builder
 * @param boolean isOpen
 */
static addIsOpen(builder:flatbuffers.Builder, isOpen:boolean) {
  builder.addFieldInt8(0, +isOpen, +false);
};

/**
 * @param flatbuffers.Builder builder
 * @param number at
 */
static addAt(builder:flatbuffers.Builder, at:number) {
  builder.addFieldInt32(1, at, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param number frame
 */
static addFrame(builder:flatbuffers.Builder, frame:number) {
  builder.addFieldInt32(2, frame, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
static endProfilerEvent(builder:flatbuffers.Builder):flatbuffers.Offset {
  var offset = builder.endObject();
  return offset;
};

static createProfilerEvent(builder:flatbuffers.Builder, isOpen:boolean, at:number, frame:number):flatbuffers.Offset {
  ProfilerEvent.startProfilerEvent(builder);
  ProfilerEvent.addIsOpen(builder, isOpen);
  ProfilerEvent.addAt(builder, at);
  ProfilerEvent.addFrame(builder, frame);
  return ProfilerEvent.endProfilerEvent(builder);
}
}
}
/**
 * A profile contains all events and is labeled with a name.
 *
 * @constructor
 */
export namespace battlecode.schema{
export class ProfilerProfile {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns ProfilerProfile
 */
__init(i:number, bb:flatbuffers.ByteBuffer):ProfilerProfile {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param ProfilerProfile= obj
 * @returns ProfilerProfile
 */
static getRootAsProfilerProfile(bb:flatbuffers.ByteBuffer, obj?:ProfilerProfile):ProfilerProfile {
  return (obj || new ProfilerProfile()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param ProfilerProfile= obj
 * @returns ProfilerProfile
 */
static getSizePrefixedRootAsProfilerProfile(bb:flatbuffers.ByteBuffer, obj?:ProfilerProfile):ProfilerProfile {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new ProfilerProfile()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * The display-friendly name of the profile.
 *
 * @param flatbuffers.Encoding= optionalEncoding
 * @returns string|Uint8Array|null
 */
name():string|null
name(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
name(optionalEncoding?:any):string|Uint8Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
};

/**
 * The events that occurred in the profile.
 *
 * @param number index
 * @param battlecode.schema.ProfilerEvent= obj
 * @returns battlecode.schema.ProfilerEvent
 */
events(index: number, obj?:battlecode.schema.ProfilerEvent):battlecode.schema.ProfilerEvent|null {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? (obj || new battlecode.schema.ProfilerEvent()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;
};

/**
 * @returns number
 */
eventsLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @param flatbuffers.Builder builder
 */
static startProfilerProfile(builder:flatbuffers.Builder) {
  builder.startObject(2);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset nameOffset
 */
static addName(builder:flatbuffers.Builder, nameOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, nameOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset eventsOffset
 */
static addEvents(builder:flatbuffers.Builder, eventsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, eventsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<flatbuffers.Offset> data
 * @returns flatbuffers.Offset
 */
static createEventsVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startEventsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
static endProfilerProfile(builder:flatbuffers.Builder):flatbuffers.Offset {
  var offset = builder.endObject();
  return offset;
};

static createProfilerProfile(builder:flatbuffers.Builder, nameOffset:flatbuffers.Offset, eventsOffset:flatbuffers.Offset):flatbuffers.Offset {
  ProfilerProfile.startProfilerProfile(builder);
  ProfilerProfile.addName(builder, nameOffset);
  ProfilerProfile.addEvents(builder, eventsOffset);
  return ProfilerProfile.endProfilerProfile(builder);
}
}
}
/**
 * A profiler file is a collection of profiles.
 * When profiling is enabled there is one of these per team per match.
 *
 * @constructor
 */
export namespace battlecode.schema{
export class ProfilerFile {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns ProfilerFile
 */
__init(i:number, bb:flatbuffers.ByteBuffer):ProfilerFile {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param ProfilerFile= obj
 * @returns ProfilerFile
 */
static getRootAsProfilerFile(bb:flatbuffers.ByteBuffer, obj?:ProfilerFile):ProfilerFile {
  return (obj || new ProfilerFile()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param ProfilerFile= obj
 * @returns ProfilerFile
 */
static getSizePrefixedRootAsProfilerFile(bb:flatbuffers.ByteBuffer, obj?:ProfilerFile):ProfilerFile {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new ProfilerFile()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * The method names that are referred to in the events.
 *
 * @param number index
 * @param flatbuffers.Encoding= optionalEncoding
 * @returns string|Uint8Array
 */
frames(index: number):string
frames(index: number,optionalEncoding:flatbuffers.Encoding):string|Uint8Array
frames(index: number,optionalEncoding?:any):string|Uint8Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
};

/**
 * @returns number
 */
framesLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * The recorded profiles, one per robot.
 *
 * @param number index
 * @param battlecode.schema.ProfilerProfile= obj
 * @returns battlecode.schema.ProfilerProfile
 */
profiles(index: number, obj?:battlecode.schema.ProfilerProfile):battlecode.schema.ProfilerProfile|null {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? (obj || new battlecode.schema.ProfilerProfile()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;
};

/**
 * @returns number
 */
profilesLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @param flatbuffers.Builder builder
 */
static startProfilerFile(builder:flatbuffers.Builder) {
  builder.startObject(2);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset framesOffset
 */
static addFrames(builder:flatbuffers.Builder, framesOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, framesOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<flatbuffers.Offset> data
 * @returns flatbuffers.Offset
 */
static createFramesVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startFramesVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset profilesOffset
 */
static addProfiles(builder:flatbuffers.Builder, profilesOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, profilesOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<flatbuffers.Offset> data
 * @returns flatbuffers.Offset
 */
static createProfilesVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startProfilesVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
static endProfilerFile(builder:flatbuffers.Builder):flatbuffers.Offset {
  var offset = builder.endObject();
  return offset;
};

static createProfilerFile(builder:flatbuffers.Builder, framesOffset:flatbuffers.Offset, profilesOffset:flatbuffers.Offset):flatbuffers.Offset {
  ProfilerFile.startProfilerFile(builder);
  ProfilerFile.addFrames(builder, framesOffset);
  ProfilerFile.addProfiles(builder, profilesOffset);
  return ProfilerFile.endProfilerFile(builder);
}
}
}
/**
 * The first event sent in the game. Contains all metadata about the game.
 *
 * @constructor
 */
export namespace battlecode.schema{
export class GameHeader {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns GameHeader
 */
__init(i:number, bb:flatbuffers.ByteBuffer):GameHeader {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param GameHeader= obj
 * @returns GameHeader
 */
static getRootAsGameHeader(bb:flatbuffers.ByteBuffer, obj?:GameHeader):GameHeader {
  return (obj || new GameHeader()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param GameHeader= obj
 * @returns GameHeader
 */
static getSizePrefixedRootAsGameHeader(bb:flatbuffers.ByteBuffer, obj?:GameHeader):GameHeader {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new GameHeader()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * The version of the spec this game complies with.
 *
 * @param flatbuffers.Encoding= optionalEncoding
 * @returns string|Uint8Array|null
 */
specVersion():string|null
specVersion(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
specVersion(optionalEncoding?:any):string|Uint8Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
};

/**
 * The teams participating in the game.
 *
 * @param number index
 * @param battlecode.schema.TeamData= obj
 * @returns battlecode.schema.TeamData
 */
teams(index: number, obj?:battlecode.schema.TeamData):battlecode.schema.TeamData|null {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? (obj || new battlecode.schema.TeamData()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;
};

/**
 * @returns number
 */
teamsLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * Information about all body types in the game.
 *
 * @param number index
 * @param battlecode.schema.BodyTypeMetadata= obj
 * @returns battlecode.schema.BodyTypeMetadata
 */
bodyTypeMetadata(index: number, obj?:battlecode.schema.BodyTypeMetadata):battlecode.schema.BodyTypeMetadata|null {
  var offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? (obj || new battlecode.schema.BodyTypeMetadata()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;
};

/**
 * @returns number
 */
bodyTypeMetadataLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @param flatbuffers.Builder builder
 */
static startGameHeader(builder:flatbuffers.Builder) {
  builder.startObject(3);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset specVersionOffset
 */
static addSpecVersion(builder:flatbuffers.Builder, specVersionOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, specVersionOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset teamsOffset
 */
static addTeams(builder:flatbuffers.Builder, teamsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, teamsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<flatbuffers.Offset> data
 * @returns flatbuffers.Offset
 */
static createTeamsVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startTeamsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset bodyTypeMetadataOffset
 */
static addBodyTypeMetadata(builder:flatbuffers.Builder, bodyTypeMetadataOffset:flatbuffers.Offset) {
  builder.addFieldOffset(2, bodyTypeMetadataOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<flatbuffers.Offset> data
 * @returns flatbuffers.Offset
 */
static createBodyTypeMetadataVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startBodyTypeMetadataVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
static endGameHeader(builder:flatbuffers.Builder):flatbuffers.Offset {
  var offset = builder.endObject();
  return offset;
};

static createGameHeader(builder:flatbuffers.Builder, specVersionOffset:flatbuffers.Offset, teamsOffset:flatbuffers.Offset, bodyTypeMetadataOffset:flatbuffers.Offset):flatbuffers.Offset {
  GameHeader.startGameHeader(builder);
  GameHeader.addSpecVersion(builder, specVersionOffset);
  GameHeader.addTeams(builder, teamsOffset);
  GameHeader.addBodyTypeMetadata(builder, bodyTypeMetadataOffset);
  return GameHeader.endGameHeader(builder);
}
}
}
/**
 * The final event sent in the game.
 *
 * @constructor
 */
export namespace battlecode.schema{
export class GameFooter {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns GameFooter
 */
__init(i:number, bb:flatbuffers.ByteBuffer):GameFooter {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param GameFooter= obj
 * @returns GameFooter
 */
static getRootAsGameFooter(bb:flatbuffers.ByteBuffer, obj?:GameFooter):GameFooter {
  return (obj || new GameFooter()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param GameFooter= obj
 * @returns GameFooter
 */
static getSizePrefixedRootAsGameFooter(bb:flatbuffers.ByteBuffer, obj?:GameFooter):GameFooter {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new GameFooter()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * The ID of the winning team of the game.
 *
 * @returns number
 */
winner():number {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.readInt8(this.bb_pos + offset) : 0;
};

/**
 * @param flatbuffers.Builder builder
 */
static startGameFooter(builder:flatbuffers.Builder) {
  builder.startObject(1);
};

/**
 * @param flatbuffers.Builder builder
 * @param number winner
 */
static addWinner(builder:flatbuffers.Builder, winner:number) {
  builder.addFieldInt8(0, winner, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
static endGameFooter(builder:flatbuffers.Builder):flatbuffers.Offset {
  var offset = builder.endObject();
  return offset;
};

static createGameFooter(builder:flatbuffers.Builder, winner:number):flatbuffers.Offset {
  GameFooter.startGameFooter(builder);
  GameFooter.addWinner(builder, winner);
  return GameFooter.endGameFooter(builder);
}
}
}
/**
 * Sent to start a match.
 *
 * @constructor
 */
export namespace battlecode.schema{
export class MatchHeader {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns MatchHeader
 */
__init(i:number, bb:flatbuffers.ByteBuffer):MatchHeader {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param MatchHeader= obj
 * @returns MatchHeader
 */
static getRootAsMatchHeader(bb:flatbuffers.ByteBuffer, obj?:MatchHeader):MatchHeader {
  return (obj || new MatchHeader()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param MatchHeader= obj
 * @returns MatchHeader
 */
static getSizePrefixedRootAsMatchHeader(bb:flatbuffers.ByteBuffer, obj?:MatchHeader):MatchHeader {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new MatchHeader()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * The map the match was played on.
 *
 * @param battlecode.schema.GameMap= obj
 * @returns battlecode.schema.GameMap|null
 */
map(obj?:battlecode.schema.GameMap):battlecode.schema.GameMap|null {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? (obj || new battlecode.schema.GameMap()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;
};

/**
 * The maximum number of rounds in this match.
 *
 * @returns number
 */
maxRounds():number {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
};

/**
 * @param flatbuffers.Builder builder
 */
static startMatchHeader(builder:flatbuffers.Builder) {
  builder.startObject(2);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset mapOffset
 */
static addMap(builder:flatbuffers.Builder, mapOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, mapOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param number maxRounds
 */
static addMaxRounds(builder:flatbuffers.Builder, maxRounds:number) {
  builder.addFieldInt32(1, maxRounds, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
static endMatchHeader(builder:flatbuffers.Builder):flatbuffers.Offset {
  var offset = builder.endObject();
  return offset;
};

static createMatchHeader(builder:flatbuffers.Builder, mapOffset:flatbuffers.Offset, maxRounds:number):flatbuffers.Offset {
  MatchHeader.startMatchHeader(builder);
  MatchHeader.addMap(builder, mapOffset);
  MatchHeader.addMaxRounds(builder, maxRounds);
  return MatchHeader.endMatchHeader(builder);
}
}
}
/**
 * Sent to end a match.
 *
 * @constructor
 */
export namespace battlecode.schema{
export class MatchFooter {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns MatchFooter
 */
__init(i:number, bb:flatbuffers.ByteBuffer):MatchFooter {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param MatchFooter= obj
 * @returns MatchFooter
 */
static getRootAsMatchFooter(bb:flatbuffers.ByteBuffer, obj?:MatchFooter):MatchFooter {
  return (obj || new MatchFooter()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param MatchFooter= obj
 * @returns MatchFooter
 */
static getSizePrefixedRootAsMatchFooter(bb:flatbuffers.ByteBuffer, obj?:MatchFooter):MatchFooter {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new MatchFooter()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * The ID of the winning team.
 *
 * @returns number
 */
winner():number {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.readInt8(this.bb_pos + offset) : 0;
};

/**
 * The number of rounds played.
 *
 * @returns number
 */
totalRounds():number {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
};

/**
 * @param flatbuffers.Builder builder
 */
static startMatchFooter(builder:flatbuffers.Builder) {
  builder.startObject(2);
};

/**
 * @param flatbuffers.Builder builder
 * @param number winner
 */
static addWinner(builder:flatbuffers.Builder, winner:number) {
  builder.addFieldInt8(0, winner, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param number totalRounds
 */
static addTotalRounds(builder:flatbuffers.Builder, totalRounds:number) {
  builder.addFieldInt32(1, totalRounds, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
static endMatchFooter(builder:flatbuffers.Builder):flatbuffers.Offset {
  var offset = builder.endObject();
  return offset;
};

static createMatchFooter(builder:flatbuffers.Builder, winner:number, totalRounds:number):flatbuffers.Offset {
  MatchFooter.startMatchFooter(builder);
  MatchFooter.addWinner(builder, winner);
  MatchFooter.addTotalRounds(builder, totalRounds);
  return MatchFooter.endMatchFooter(builder);
}
}
}
/**
 * A single time-step in a Game.
 * The bulk of the data in the file is stored in tables like this.
 * Note that a struct-of-arrays format is more space efficient than an array-
 * of-structs.
 *
 * @constructor
 */
export namespace battlecode.schema{
export class Round {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns Round
 */
__init(i:number, bb:flatbuffers.ByteBuffer):Round {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param Round= obj
 * @returns Round
 */
static getRootAsRound(bb:flatbuffers.ByteBuffer, obj?:Round):Round {
  return (obj || new Round()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param Round= obj
 * @returns Round
 */
static getSizePrefixedRootAsRound(bb:flatbuffers.ByteBuffer, obj?:Round):Round {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new Round()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * The IDs of teams in the Game.
 *
 * @param number index
 * @returns number
 */
teamIDs(index: number):number|null {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
};

/**
 * @returns number
 */
teamIDsLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int32Array
 */
teamIDsArray():Int32Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? new Int32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * whether a team gets a vp
 *
 * @param number index
 * @returns boolean
 */
teamVPs(index: number):boolean|null {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? !!this.bb!.readInt8(this.bb!.__vector(this.bb_pos + offset) + index) : false;
};

/**
 * @returns number
 */
teamVPsLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int8Array
 */
teamVPsArray():Int8Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? new Int8Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * the id of the enlightenment center got the bid
 *
 * @param number index
 * @returns number
 */
teamVoterID(index: number):number|null {
  var offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
};

/**
 * @returns number
 */
teamVoterIDLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int32Array
 */
teamVoterIDArray():Int32Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? new Int32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * The IDs of bodies that moved.
 *
 * @param number index
 * @returns number
 */
movedIDs(index: number):number|null {
  var offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
};

/**
 * @returns number
 */
movedIDsLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int32Array
 */
movedIDsArray():Int32Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? new Int32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * The new locations of bodies that have moved.
 *
 * @param battlecode.schema.VecTable= obj
 * @returns battlecode.schema.VecTable|null
 */
movedLocs(obj?:battlecode.schema.VecTable):battlecode.schema.VecTable|null {
  var offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? (obj || new battlecode.schema.VecTable()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;
};

/**
 * New bodies.
 *
 * @param battlecode.schema.SpawnedBodyTable= obj
 * @returns battlecode.schema.SpawnedBodyTable|null
 */
spawnedBodies(obj?:battlecode.schema.SpawnedBodyTable):battlecode.schema.SpawnedBodyTable|null {
  var offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? (obj || new battlecode.schema.SpawnedBodyTable()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;
};

/**
 * The IDs of bodies that died.
 *
 * @param number index
 * @returns number
 */
diedIDs(index: number):number|null {
  var offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
};

/**
 * @returns number
 */
diedIDsLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int32Array
 */
diedIDsArray():Int32Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? new Int32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * The IDs of robots that performed actions.
 * IDs may repeat.
 *
 * @param number index
 * @returns number
 */
actionIDs(index: number):number|null {
  var offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
};

/**
 * @returns number
 */
actionIDsLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int32Array
 */
actionIDsArray():Int32Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? new Int32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * The actions performed. These actions allow us to track how much soup or dirt a body carries.
 *
 * @param number index
 * @returns battlecode.schema.Action
 */
actions(index: number):battlecode.schema.Action|null {
  var offset = this.bb!.__offset(this.bb_pos, 20);
  return offset ? /**  */ (this.bb!.readInt8(this.bb!.__vector(this.bb_pos + offset) + index)) : /**  */ (0);
};

/**
 * @returns number
 */
actionsLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 20);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int8Array
 */
actionsArray():Int8Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 20);
  return offset ? new Int8Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * The 'targets' of the performed actions. Actions without targets may have any value
 *
 * @param number index
 * @returns number
 */
actionTargets(index: number):number|null {
  var offset = this.bb!.__offset(this.bb_pos, 22);
  return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
};

/**
 * @returns number
 */
actionTargetsLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 22);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int32Array
 */
actionTargetsArray():Int32Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 22);
  return offset ? new Int32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * The IDs of bodies that set indicator dots
 *
 * @param number index
 * @returns number
 */
indicatorDotIDs(index: number):number|null {
  var offset = this.bb!.__offset(this.bb_pos, 24);
  return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
};

/**
 * @returns number
 */
indicatorDotIDsLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 24);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int32Array
 */
indicatorDotIDsArray():Int32Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 24);
  return offset ? new Int32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * The location of the indicator dots
 *
 * @param battlecode.schema.VecTable= obj
 * @returns battlecode.schema.VecTable|null
 */
indicatorDotLocs(obj?:battlecode.schema.VecTable):battlecode.schema.VecTable|null {
  var offset = this.bb!.__offset(this.bb_pos, 26);
  return offset ? (obj || new battlecode.schema.VecTable()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;
};

/**
 * The RGB values of the indicator dots
 *
 * @param battlecode.schema.RGBTable= obj
 * @returns battlecode.schema.RGBTable|null
 */
indicatorDotRGBs(obj?:battlecode.schema.RGBTable):battlecode.schema.RGBTable|null {
  var offset = this.bb!.__offset(this.bb_pos, 28);
  return offset ? (obj || new battlecode.schema.RGBTable()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;
};

/**
 * The IDs of bodies that set indicator lines
 *
 * @param number index
 * @returns number
 */
indicatorLineIDs(index: number):number|null {
  var offset = this.bb!.__offset(this.bb_pos, 30);
  return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
};

/**
 * @returns number
 */
indicatorLineIDsLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 30);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int32Array
 */
indicatorLineIDsArray():Int32Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 30);
  return offset ? new Int32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * The start location of the indicator lines
 *
 * @param battlecode.schema.VecTable= obj
 * @returns battlecode.schema.VecTable|null
 */
indicatorLineStartLocs(obj?:battlecode.schema.VecTable):battlecode.schema.VecTable|null {
  var offset = this.bb!.__offset(this.bb_pos, 32);
  return offset ? (obj || new battlecode.schema.VecTable()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;
};

/**
 * The end location of the indicator lines
 *
 * @param battlecode.schema.VecTable= obj
 * @returns battlecode.schema.VecTable|null
 */
indicatorLineEndLocs(obj?:battlecode.schema.VecTable):battlecode.schema.VecTable|null {
  var offset = this.bb!.__offset(this.bb_pos, 34);
  return offset ? (obj || new battlecode.schema.VecTable()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;
};

/**
 * The RGB values of the indicator lines
 *
 * @param battlecode.schema.RGBTable= obj
 * @returns battlecode.schema.RGBTable|null
 */
indicatorLineRGBs(obj?:battlecode.schema.RGBTable):battlecode.schema.RGBTable|null {
  var offset = this.bb!.__offset(this.bb_pos, 36);
  return offset ? (obj || new battlecode.schema.RGBTable()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;
};

/**
 * All logs sent this round.
 * Messages from a particular robot in this round start on a new line, and
 * have a header:
 * '[' $TEAM ':' $ROBOTTYPE '#' $ID '@' $ROUND '] '
 * $TEAM = 'A' | 'B'
 * $ROBOTTYPE = 'HQ' | 'VAPORATOR' | 'LANDSCAPER' 
 *            | 'DELIVERY_DRONE' | 'REFINERY' | 'MINER' | other names...
 * $ID = a number
 * $ROUND = a number
 * The header is not necessarily followed by a newline.
 * This header should only be sent once per robot per round (although
 * players may forge it, so don't crash if you get strange input.)
 *
 * You should try to only read this value once, and cache it. Reading
 * strings from a flatbuffer is much less efficient than reading other
 * buffers, because they need to be copied into an environment-provided
 * buffer and validated.
 *
 * (haha i guess you can never really escape string parsing can you)
 *
 * @param flatbuffers.Encoding= optionalEncoding
 * @returns string|Uint8Array|null
 */
logs():string|null
logs(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
logs(optionalEncoding?:any):string|Uint8Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 38);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
};

/**
 * The first sent Round in a match should have index 1. (The starting state,
 * created by the MatchHeader, can be thought to have index 0.)
 * It should increase by one for each following round.
 *
 * @returns number
 */
roundID():number {
  var offset = this.bb!.__offset(this.bb_pos, 40);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
};

/**
 * The IDs of player bodies.
 *
 * @param number index
 * @returns number
 */
bytecodeIDs(index: number):number|null {
  var offset = this.bb!.__offset(this.bb_pos, 42);
  return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
};

/**
 * @returns number
 */
bytecodeIDsLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 42);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int32Array
 */
bytecodeIDsArray():Int32Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 42);
  return offset ? new Int32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * The bytecodes used by the player bodies.
 *
 * @param number index
 * @returns number
 */
bytecodesUsed(index: number):number|null {
  var offset = this.bb!.__offset(this.bb_pos, 44);
  return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
};

/**
 * @returns number
 */
bytecodesUsedLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 44);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int32Array
 */
bytecodesUsedArray():Int32Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 44);
  return offset ? new Int32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * @param flatbuffers.Builder builder
 */
static startRound(builder:flatbuffers.Builder) {
  builder.startObject(21);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset teamIDsOffset
 */
static addTeamIDs(builder:flatbuffers.Builder, teamIDsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, teamIDsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<number> data
 * @returns flatbuffers.Offset
 */
static createTeamIDsVector(builder:flatbuffers.Builder, data:number[] | Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startTeamIDsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset teamVPsOffset
 */
static addTeamVPs(builder:flatbuffers.Builder, teamVPsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, teamVPsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<boolean> data
 * @returns flatbuffers.Offset
 */
static createTeamVPsVector(builder:flatbuffers.Builder, data:boolean[]):flatbuffers.Offset {
  builder.startVector(1, data.length, 1);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt8(+data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startTeamVPsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(1, numElems, 1);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset teamVoterIDOffset
 */
static addTeamVoterID(builder:flatbuffers.Builder, teamVoterIDOffset:flatbuffers.Offset) {
  builder.addFieldOffset(2, teamVoterIDOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<number> data
 * @returns flatbuffers.Offset
 */
static createTeamVoterIDVector(builder:flatbuffers.Builder, data:number[] | Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startTeamVoterIDVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset movedIDsOffset
 */
static addMovedIDs(builder:flatbuffers.Builder, movedIDsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(3, movedIDsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<number> data
 * @returns flatbuffers.Offset
 */
static createMovedIDsVector(builder:flatbuffers.Builder, data:number[] | Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startMovedIDsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset movedLocsOffset
 */
static addMovedLocs(builder:flatbuffers.Builder, movedLocsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(4, movedLocsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset spawnedBodiesOffset
 */
static addSpawnedBodies(builder:flatbuffers.Builder, spawnedBodiesOffset:flatbuffers.Offset) {
  builder.addFieldOffset(5, spawnedBodiesOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset diedIDsOffset
 */
static addDiedIDs(builder:flatbuffers.Builder, diedIDsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(6, diedIDsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<number> data
 * @returns flatbuffers.Offset
 */
static createDiedIDsVector(builder:flatbuffers.Builder, data:number[] | Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startDiedIDsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset actionIDsOffset
 */
static addActionIDs(builder:flatbuffers.Builder, actionIDsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(7, actionIDsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<number> data
 * @returns flatbuffers.Offset
 */
static createActionIDsVector(builder:flatbuffers.Builder, data:number[] | Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startActionIDsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset actionsOffset
 */
static addActions(builder:flatbuffers.Builder, actionsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(8, actionsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<battlecode.schema.Action> data
 * @returns flatbuffers.Offset
 */
static createActionsVector(builder:flatbuffers.Builder, data:battlecode.schema.Action[]):flatbuffers.Offset {
  builder.startVector(1, data.length, 1);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt8(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startActionsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(1, numElems, 1);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset actionTargetsOffset
 */
static addActionTargets(builder:flatbuffers.Builder, actionTargetsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(9, actionTargetsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<number> data
 * @returns flatbuffers.Offset
 */
static createActionTargetsVector(builder:flatbuffers.Builder, data:number[] | Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startActionTargetsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset indicatorDotIDsOffset
 */
static addIndicatorDotIDs(builder:flatbuffers.Builder, indicatorDotIDsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(10, indicatorDotIDsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<number> data
 * @returns flatbuffers.Offset
 */
static createIndicatorDotIDsVector(builder:flatbuffers.Builder, data:number[] | Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startIndicatorDotIDsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset indicatorDotLocsOffset
 */
static addIndicatorDotLocs(builder:flatbuffers.Builder, indicatorDotLocsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(11, indicatorDotLocsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset indicatorDotRGBsOffset
 */
static addIndicatorDotRGBs(builder:flatbuffers.Builder, indicatorDotRGBsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(12, indicatorDotRGBsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset indicatorLineIDsOffset
 */
static addIndicatorLineIDs(builder:flatbuffers.Builder, indicatorLineIDsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(13, indicatorLineIDsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<number> data
 * @returns flatbuffers.Offset
 */
static createIndicatorLineIDsVector(builder:flatbuffers.Builder, data:number[] | Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startIndicatorLineIDsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset indicatorLineStartLocsOffset
 */
static addIndicatorLineStartLocs(builder:flatbuffers.Builder, indicatorLineStartLocsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(14, indicatorLineStartLocsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset indicatorLineEndLocsOffset
 */
static addIndicatorLineEndLocs(builder:flatbuffers.Builder, indicatorLineEndLocsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(15, indicatorLineEndLocsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset indicatorLineRGBsOffset
 */
static addIndicatorLineRGBs(builder:flatbuffers.Builder, indicatorLineRGBsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(16, indicatorLineRGBsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset logsOffset
 */
static addLogs(builder:flatbuffers.Builder, logsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(17, logsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param number roundID
 */
static addRoundID(builder:flatbuffers.Builder, roundID:number) {
  builder.addFieldInt32(18, roundID, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset bytecodeIDsOffset
 */
static addBytecodeIDs(builder:flatbuffers.Builder, bytecodeIDsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(19, bytecodeIDsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<number> data
 * @returns flatbuffers.Offset
 */
static createBytecodeIDsVector(builder:flatbuffers.Builder, data:number[] | Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startBytecodeIDsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset bytecodesUsedOffset
 */
static addBytecodesUsed(builder:flatbuffers.Builder, bytecodesUsedOffset:flatbuffers.Offset) {
  builder.addFieldOffset(20, bytecodesUsedOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<number> data
 * @returns flatbuffers.Offset
 */
static createBytecodesUsedVector(builder:flatbuffers.Builder, data:number[] | Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startBytecodesUsedVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
static endRound(builder:flatbuffers.Builder):flatbuffers.Offset {
  var offset = builder.endObject();
  return offset;
};

static createRound(builder:flatbuffers.Builder, teamIDsOffset:flatbuffers.Offset, teamVPsOffset:flatbuffers.Offset, teamVoterIDOffset:flatbuffers.Offset, movedIDsOffset:flatbuffers.Offset, movedLocsOffset:flatbuffers.Offset, spawnedBodiesOffset:flatbuffers.Offset, diedIDsOffset:flatbuffers.Offset, actionIDsOffset:flatbuffers.Offset, actionsOffset:flatbuffers.Offset, actionTargetsOffset:flatbuffers.Offset, indicatorDotIDsOffset:flatbuffers.Offset, indicatorDotLocsOffset:flatbuffers.Offset, indicatorDotRGBsOffset:flatbuffers.Offset, indicatorLineIDsOffset:flatbuffers.Offset, indicatorLineStartLocsOffset:flatbuffers.Offset, indicatorLineEndLocsOffset:flatbuffers.Offset, indicatorLineRGBsOffset:flatbuffers.Offset, logsOffset:flatbuffers.Offset, roundID:number, bytecodeIDsOffset:flatbuffers.Offset, bytecodesUsedOffset:flatbuffers.Offset):flatbuffers.Offset {
  Round.startRound(builder);
  Round.addTeamIDs(builder, teamIDsOffset);
  Round.addTeamVPs(builder, teamVPsOffset);
  Round.addTeamVoterID(builder, teamVoterIDOffset);
  Round.addMovedIDs(builder, movedIDsOffset);
  Round.addMovedLocs(builder, movedLocsOffset);
  Round.addSpawnedBodies(builder, spawnedBodiesOffset);
  Round.addDiedIDs(builder, diedIDsOffset);
  Round.addActionIDs(builder, actionIDsOffset);
  Round.addActions(builder, actionsOffset);
  Round.addActionTargets(builder, actionTargetsOffset);
  Round.addIndicatorDotIDs(builder, indicatorDotIDsOffset);
  Round.addIndicatorDotLocs(builder, indicatorDotLocsOffset);
  Round.addIndicatorDotRGBs(builder, indicatorDotRGBsOffset);
  Round.addIndicatorLineIDs(builder, indicatorLineIDsOffset);
  Round.addIndicatorLineStartLocs(builder, indicatorLineStartLocsOffset);
  Round.addIndicatorLineEndLocs(builder, indicatorLineEndLocsOffset);
  Round.addIndicatorLineRGBs(builder, indicatorLineRGBsOffset);
  Round.addLogs(builder, logsOffset);
  Round.addRoundID(builder, roundID);
  Round.addBytecodeIDs(builder, bytecodeIDsOffset);
  Round.addBytecodesUsed(builder, bytecodesUsedOffset);
  return Round.endRound(builder);
}
}
}
/**
 * Necessary due to flatbuffers requiring unions to be wrapped in tables.
 *
 * @constructor
 */
export namespace battlecode.schema{
export class EventWrapper {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns EventWrapper
 */
__init(i:number, bb:flatbuffers.ByteBuffer):EventWrapper {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param EventWrapper= obj
 * @returns EventWrapper
 */
static getRootAsEventWrapper(bb:flatbuffers.ByteBuffer, obj?:EventWrapper):EventWrapper {
  return (obj || new EventWrapper()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param EventWrapper= obj
 * @returns EventWrapper
 */
static getSizePrefixedRootAsEventWrapper(bb:flatbuffers.ByteBuffer, obj?:EventWrapper):EventWrapper {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new EventWrapper()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @returns battlecode.schema.Event
 */
eType():battlecode.schema.Event {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? /**  */ (this.bb!.readUint8(this.bb_pos + offset)) : battlecode.schema.Event.NONE;
};

/**
 * @param flatbuffers.Table obj
 * @returns ?flatbuffers.Table
 */
e<T extends flatbuffers.Table>(obj:T):T|null {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__union(obj, this.bb_pos + offset) : null;
};

/**
 * @param flatbuffers.Builder builder
 */
static startEventWrapper(builder:flatbuffers.Builder) {
  builder.startObject(2);
};

/**
 * @param flatbuffers.Builder builder
 * @param battlecode.schema.Event eType
 */
static addEType(builder:flatbuffers.Builder, eType:battlecode.schema.Event) {
  builder.addFieldInt8(0, eType, battlecode.schema.Event.NONE);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset eOffset
 */
static addE(builder:flatbuffers.Builder, eOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, eOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
static endEventWrapper(builder:flatbuffers.Builder):flatbuffers.Offset {
  var offset = builder.endObject();
  return offset;
};

static createEventWrapper(builder:flatbuffers.Builder, eType:battlecode.schema.Event, eOffset:flatbuffers.Offset):flatbuffers.Offset {
  EventWrapper.startEventWrapper(builder);
  EventWrapper.addEType(builder, eType);
  EventWrapper.addE(builder, eOffset);
  return EventWrapper.endEventWrapper(builder);
}
}
}
/**
 * If events are not otherwise delimited, this wrapper structure
 * allows a game to be stored in a single buffer.
 * The first event will be a GameHeader; the last event will be a GameFooter.
 * matchHeaders[0] is the index of the 0th match header in the event stream,
 * corresponding to matchFooters[0]. These indices allow quick traversal of
 * the file.
 *
 * @constructor
 */
export namespace battlecode.schema{
export class GameWrapper {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns GameWrapper
 */
__init(i:number, bb:flatbuffers.ByteBuffer):GameWrapper {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param GameWrapper= obj
 * @returns GameWrapper
 */
static getRootAsGameWrapper(bb:flatbuffers.ByteBuffer, obj?:GameWrapper):GameWrapper {
  return (obj || new GameWrapper()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param GameWrapper= obj
 * @returns GameWrapper
 */
static getSizePrefixedRootAsGameWrapper(bb:flatbuffers.ByteBuffer, obj?:GameWrapper):GameWrapper {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new GameWrapper()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * The series of events comprising the game.
 *
 * @param number index
 * @param battlecode.schema.EventWrapper= obj
 * @returns battlecode.schema.EventWrapper
 */
events(index: number, obj?:battlecode.schema.EventWrapper):battlecode.schema.EventWrapper|null {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? (obj || new battlecode.schema.EventWrapper()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;
};

/**
 * @returns number
 */
eventsLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * The indices of the headers of the matches, in order.
 *
 * @param number index
 * @returns number
 */
matchHeaders(index: number):number|null {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
};

/**
 * @returns number
 */
matchHeadersLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int32Array
 */
matchHeadersArray():Int32Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? new Int32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * The indices of the footers of the matches, in order.
 *
 * @param number index
 * @returns number
 */
matchFooters(index: number):number|null {
  var offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
};

/**
 * @returns number
 */
matchFootersLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int32Array
 */
matchFootersArray():Int32Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? new Int32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * @param flatbuffers.Builder builder
 */
static startGameWrapper(builder:flatbuffers.Builder) {
  builder.startObject(3);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset eventsOffset
 */
static addEvents(builder:flatbuffers.Builder, eventsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, eventsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<flatbuffers.Offset> data
 * @returns flatbuffers.Offset
 */
static createEventsVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startEventsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset matchHeadersOffset
 */
static addMatchHeaders(builder:flatbuffers.Builder, matchHeadersOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, matchHeadersOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<number> data
 * @returns flatbuffers.Offset
 */
static createMatchHeadersVector(builder:flatbuffers.Builder, data:number[] | Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startMatchHeadersVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset matchFootersOffset
 */
static addMatchFooters(builder:flatbuffers.Builder, matchFootersOffset:flatbuffers.Offset) {
  builder.addFieldOffset(2, matchFootersOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<number> data
 * @returns flatbuffers.Offset
 */
static createMatchFootersVector(builder:flatbuffers.Builder, data:number[] | Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startMatchFootersVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
static endGameWrapper(builder:flatbuffers.Builder):flatbuffers.Offset {
  var offset = builder.endObject();
  return offset;
};

static createGameWrapper(builder:flatbuffers.Builder, eventsOffset:flatbuffers.Offset, matchHeadersOffset:flatbuffers.Offset, matchFootersOffset:flatbuffers.Offset):flatbuffers.Offset {
  GameWrapper.startGameWrapper(builder);
  GameWrapper.addEvents(builder, eventsOffset);
  GameWrapper.addMatchHeaders(builder, matchHeadersOffset);
  GameWrapper.addMatchFooters(builder, matchFootersOffset);
  return GameWrapper.endGameWrapper(builder);
}
}
}
